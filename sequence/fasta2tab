#!/usr/bin/env perl
# https://github.com/shenwei356/bio_scripts

use strict;
use Getopt::Long;
use BioUtil::Seq;
use BioUtil::Util;

my $usage = q(
fasta2tab - transform the fasta fromat to two-column table

Usage: $0 [options] [fastafiles...]
Options:    
    -r,  --reverse             Reverse sequence
    -c,  --complement          Complement sequence
    -rc, --reversecomplement   Reversecomplement

    -t,  --trim                Trim non-Latin alphabet
    -lc, --lowercase           Lowercase
    -uc, --uppercase           Uppercase

    -l,  --length              Ouput sequence length at another column
    -l2, --length2             Ouput number of latin-letter in sequence 
                               at another column
    -gc, --gc                  Ouput GC content at another column

    -h,  --help                Show this help information

Examples:

    1. sort fasta by sequnece length
       cat seq.fa | fasta2tab -t -l | sort -r -t"`echo -e '\t'`" -n -k3,3 \
         |  tab2fasta -l 70 > seq.sorted.fa

    2. extract sequence longer than 1000 bp
       cat seq.fa | fasta2tab -t -l | awk -F'\t' '$3 >= 1000' | tab2fasta -l 70

    3. extract aligned sequence of which the original sequence is longer than 1000 bp
       cat seq.fa | fasta2tab   -l2 | awk -F'\t' '$3 >= 1000' | tab2fasta -l 70

    4. reverse complement sequence, uppercase, and trim gaps
       zcat seq.fa.gz | fasta2tab -uc -rc -t | tab2fasta

This script is usually used in pair with tab2fasta.
https://github.com/shenwei356/bio_scripts

);

my $para = {};
GetOptions(
    'help|h' => \$$para{help},

    'reverse|r'            => \$$para{rev},
    'complement|c'         => \$$para{comp},
    'reversecomplement|rc' => \$$para{rc},

    'trim|t'       => \$$para{trim},
    'lowercase|lc' => \$$para{lc},
    'uppercase|uc' => \$$para{uc},

    'length|l'   => \$$para{len},
    'length2|l2' => \$$para{len2},
    'gc'         => \$$para{gc},

) or die $usage;

die $usage if $$para{help};

my @files = file_list_from_argv(@ARGV);

for my $file (@files) {
    my $next_seq = FastaReader($file);
    while ( my $fa = &$next_seq() ) {
        my ( $header, $seq ) = @$fa;

        $header =~ s/\t/__tab__/g;

        if ( $$para{trim} ) {
            $seq =~ s/[^a-zA-Z]+//g;
        }

        if ( $$para{rc} ) {
            $seq = revcom($seq);
        }
        elsif ( $$para{comp} ) {
            $seq = complement($seq);
        }
        elsif ( $$para{rev} ) {
            $seq = reverse $seq;
        }

        if ( $$para{lc} ) {
            $seq = lc $seq;
        }
        elsif ( $$para{uc} ) {
            $seq = uc $seq;
        }

        print "$header\t$seq";
        print "\t", length $seq if $$para{len};
        if ($$para{len2}){
            if ($$para{trim}){
                print "\t", length $seq;
            } else {
                my $seq2 = $seq;
                $seq2 =~ s/[^a-zA-Z]+//g;
                print "\t", length $seq2;
            }
        }
        print "\t", base_content( 'gc', $seq ) if $$para{gc};
        print "\n";
    }
}
