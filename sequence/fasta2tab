#!/usr/bin/env perl
# https://github.com/shenwei356/bio_scripts

use strict;
use Getopt::Long;
use BioUtil::Seq;

my $usage = q(
fasta2tab - transfrom the fasta fromat to two-column table

Usage: $0 [options] [fastafiles...]
Options:
    
    -r,  --reverse             Reverse sequence
    -c,  --complement          Complement sequence
    -rc, --reversecomplement   Reversecomplement

    -t,  --trim                Trim non-Latin alphabet
    -lc, --lowercase           Lowercase
    -uc, --uppercase           Uppercase

    -l,  --length              Ouput sequence length in another column
    -gc, --gc                  Ouput GC content in another column

    -h,  --help                Show this help information

Examples:

    1. sort fasta by sequnece length
       cat seq.fa | fasta2tab -t -l | sort -r -t"`echo -e '\t'`" -n -k3,3 \
         |  tab2fasta -l 70 > seq.sorted.fa

    2. extract sequence longer than 1000 bp
       cat seq.fa | fasta2tab -t -l | awk -F'\t' '$3 >= 1000' | tab2fasta -l 70

    3. reverse complement sequence, uppercase, and trim gaps
       zcat seq.fa.gz | fasta2tab -uc -rc -t | tab2fasta

This script is usually used in pair with tab2fasta.
https://github.com/shenwei356/bio_scripts

);

my $para = {};
GetOptions(
    'help|h' => \$$para{help},

    'reverse|r'            => \$$para{rev},
    'complement|c'         => \$$para{comp},
    'reversecomplement|rc' => \$$para{rc},

    'trim|t'       => \$$para{trim},
    'lowercase|lc' => \$$para{lc},
    'uppercase|uc' => \$$para{uc},

    'length|l' => \$$para{len},
    'gc'       => \$$para{gc},

) or die $usage;

die $usage if $$para{help};

# get the file list
my @files = ();
for my $file (@ARGV) {
    for my $f ( glob $file ) {
        push @files, $f;
    }
}
if ( @files == 0 ) {
    push @files, 'STDIN';
}

for my $file (@files) {
    my $next_seq = FastaReader($file);
    while ( my $fa = &$next_seq() ) {
        my ( $header, $seq ) = @$fa;

        $header =~ s/\t/__tab__/g;

        if ( $$para{trim} ) {
            $seq =~ s/[^a-zA-Z]+//g;
        }

        if ( $$para{rc} ) {
            $seq = revcom($seq);
        }
        elsif ( $$para{comp} ) {
            $seq = complement($seq);
        }
        elsif ( $$para{rev} ) {
            $seq = reverse $seq;
        }

        if ( $$para{lc} ) {
            $seq = lc $seq;
        }
        elsif ( $$para{uc} ) {
            $seq = uc $seq;
        }

        print "$header\t$seq";
        print "\t", length $seq if $$para{len};
        print "\t", base_content( 'gc', $seq ) if $$para{gc};
        print "\n";
    }
}
